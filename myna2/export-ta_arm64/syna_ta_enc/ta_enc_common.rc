OPTEE_3RD_TACERT_ImageType=TA_CERT
OPTEE_3RD_TACERT_IV=
OPTEE_3RD_TACERT_SegIDMask=0xffffffff
OPTEE_3RD_TACERT_Ver=0x00000000
OPTEE_3RD_TACERT_VerMask=0xffffffff
OPTEE_3RD_TACERT_VendorGID=0x00000001
OPTEE_3RD_TACERT_CertID=0x00000001
OPTEE_3RD_TACERT_PermMagicNum=0x84658070
OPTEE_3RD_TACERT_PermVer=0x00000001
OPTEE_3RD_TACERT_PermVendorGID=0x00000001

OPTEE_3RD_TA_ImageType=TA
OPTEE_3RD_TA_IV=
OPTEE_3RD_TA_SegIDMask=0xffffffff
OPTEE_3RD_TA_Ver=0x00000000
OPTEE_3RD_TA_VerMask=0xffffffff
OPTEE_3RD_TA_VendorGID=0x00000001
OPTEE_3RD_TA_CertID=0x00000001
OPTEE_3RD_TA_UUID=00000000
OPTEE_3RD_TA_TYPE=0x00000000

if [ "$OPTEE_TA_ENC" == "dev" ]; then
OPTEE_3RD_TACERT_SegID=0x00000000
OPTEE_3RD_TACERT_ProdImgFlag=0x00000000
OPTEE_3RD_TA_SegID=0x00000000
OPTEE_3RD_TA_ProdImgFlag=0x00000000
else
OPTEE_3RD_TACERT_SegID=0x3A40FFFF
OPTEE_3RD_TACERT_ProdImgFlag=0x00000001
OPTEE_3RD_TA_SegID=0x3A40FFFF
OPTEE_3RD_TA_ProdImgFlag=0x00000001
fi

OPTEE_3RD_TA_ROOT_CERT_NAME=$security_keys_path/TA_Root_Cert.rcert

OPTEE_3RD_TA_PATH=$(dirname $1)
OPTEE_3RD_TA_BASENAME=$(basename $1 .ta)
OPTEE_3RD_TA_NAME=${OPTEE_3RD_TA_BASENAME:0:16}
OPTEE_3RD_TA_CERT_NAME=$OPTEE_3RD_TA_BASENAME.cert
OPTEE_3RD_TA_RAW_NAME=$OPTEE_3RD_TA_BASENAME.img
OPTEE_3RD_TA_IMG_NAME=$OPTEE_3RD_TA_BASENAME.ta

keys_dir=$security_keys_path/

if [ "is$OPTEE_3RD_TA_OUTPATH" != "is" ];then
  tmp_dir=$OPTEE_3RD_TA_OUTPATH/tmp
  OutputData=$OPTEE_3RD_TA_OUTPATH/
else
  tmp_dir=$OPTEE_3RD_TA_PATH/tmp
  OutputData=$OPTEE_3RD_TA_PATH/ta_enc
fi

OPTEE_3RD_TA_RAW_BIN=$OutputData/$OPTEE_3RD_TA_BASENAME.raw

OPTEE_3RD_TA_CERT_RSA_PRV=$keys_dir/TA_K0_RSA.priv.pem
OPTEE_3RD_TA_CERT_MDK=$keys_dir/TA_K0_AES_Key_TA_CERT.bin
OPTEE_3RD_TA_RSA_PUB=$keys_dir/TA_K1_RSA.pub.pem
OPTEE_3RD_TA_AES_key=$keys_dir/TA_K1_AES_Key.bin
OPTEE_3RD_TA_RSA_PRV=$keys_dir/TA_K1_RSA.priv.pem
OPTEE_3RD_TA_MDK=$keys_dir/TA_K1_AES_Key_TA.bin

TAPERM_GROUP=()

if [ "is$GENX_TOOL_PATH" == "is" ];then
  GENX_TOOL_PATH=$security_tools_path/../lib/sec_tools/bin
fi
GENX_TOOL=$GENX_TOOL_PATH/genx_img
RSA_PAYLOAD_TOOL=$GENX_TOOL_PATH/gen_rsa_payload

l_endian32() {
  echo `printf "%08x"  $1` | grep -o .. | tac | echo "$(tr -d '\n')" | xxd -r -p
}

check_file_exist() {
  if [ ! -f $1 ]; then
    printf "\nError: Cannot find the File $1\n"
    exit 1
  fi
}

gen_tacert_payload() {
  local f_out

  f_out=$1; shift

  tacert_perm=$tmp_dir/tacert_perm

  group_cnt=${#TAPERM_GROUP[@]}
  perm_len=$((20 + 20 * group_cnt))

  l_endian32 $OPTEE_3RD_TACERT_PermMagicNum >$tacert_perm
  l_endian32 $OPTEE_3RD_TACERT_PermVer  >>$tacert_perm
  l_endian32 $perm_len >>$tacert_perm
  l_endian32 $OPTEE_3RD_TACERT_PermVendorGID >>$tacert_perm
  l_endian32 ${#TAPERM_GROUP[@]} >>$tacert_perm

  if [ "$group_cnt" -ge 1 ];then
    i=$group_cnt
    while [ "$i" -gt 0 ];
    do
      i=$((i-1))
      echo -n `printf "%s" ${TAPERM_GROUP[$i]}` >>$tacert_perm
      gname_len=${#TAPERM_GROUP[$i]}
      echo `printf "%0$(((16 - gname_len) * 2))x" 0` | xxd -r -p >>$tacert_perm
      l_endian32 $gname_len >> $tacert_perm
    done
  fi

## Get pub key modules(256 bytes)
  in_rsa_pub_payload=$tmp_dir/ta_rsa_pub_modules.bin
  $RSA_PAYLOAD_TOOL -i $OPTEE_3RD_TA_RSA_PUB -o $in_rsa_pub_payload

  cat $in_rsa_pub_payload $OPTEE_3RD_TA_AES_key $tacert_perm >$f_out
}

gen_tacert_extras(){
  local f_out

  f_out=$1

  #echo "OPTEE_3RD_TACERT_ProdImgFlag is $OPTEE_3RD_TACERT_ProdImgFlag"
  l_endian32 $OPTEE_3RD_TACERT_ProdImgFlag >$f_out
  l_endian32 $OPTEE_3RD_TACERT_VendorGID >>$f_out
  l_endian32 $OPTEE_3RD_TACERT_CertID >>$f_out
}

gen_tacert_secure_image(){
  f_in_extras=$1; shift
  f_in_payload=$1; shift
  f_out=$1; shift

  ##Check input files##
  [ -f $f_in_payload ]
  [ -f $f_in_extras ]

  ## Execytable for generating secure image ##
  exec_cmd=$GENX_TOOL
  [ -x $exec_cmd ]

  ## Prepare arguments ##
  unset exec_args

  ## Image Type ##
  exec_arg="${exec_arg} -t $OPTEE_3RD_TACERT_ImageType"

  ## Encryption Key ##
  exec_arg="${exec_arg} -k $OPTEE_3RD_TA_CERT_MDK"

  ## Signing Key ##
  exec_arg="${exec_arg} -n $OPTEE_3RD_TA_CERT_RSA_PRV"

  ## SegID and SegID Mask ##
  exec_arg="${exec_arg} -s $OPTEE_3RD_TACERT_SegID"
  exec_arg="${exec_arg} -S $OPTEE_3RD_TACERT_SegIDMask"

  ## Ver and Ver Mask ##
  exec_arg="${exec_arg} -r $OPTEE_3RD_TACERT_Ver"
  exec_arg="${exec_arg} -R $OPTEE_3RD_TACERT_VerMask"

  ## Extra part ##
  exec_arg="${exec_arg} -x $f_in_extras"

  ## Requested length. 0: use variable payload lenth. fixed lenth: use fixed lenth ##
  exec_arg="${exec_arg} -l 0x0"

  ## In Payload to be encrytped and signed ##
  exec_arg="${exec_arg} -i $f_in_payload"

  ## ouput file with encyrtion, signature and header info ##
  exec_arg="${exec_arg} -o $f_out"

  echo "$exec_cmd "$exec_arg""

  # Generate secure image ##
  eval $exec_cmd "$exec_arg"
}


gen_ta_extras(){
  local f_out

  f_out=$1

 # echo "OPTEE_3RD_TA_ProdImgFlag is $OPTEE_3RD_TA_ProdImgFlag"
  l_endian32 $OPTEE_3RD_TA_ProdImgFlag >$f_out
  l_endian32 $OPTEE_3RD_TA_VendorGID >>$f_out
  l_endian32 $OPTEE_3RD_TA_CertID >>$f_out


  echo "OPTEE_3RD_TA_NAME is $OPTEE_3RD_TA_NAME"
  echo "OPTEE_3RD_TA_UUID is $OPTEE_3RD_TA_UUID"
  echo "OPTEE_3RD_TA_TYPE is $OPTEE_3RD_TA_TYPE"
  echo -n `printf "%s" ${OPTEE_3RD_TA_NAME}` >>$f_out
  gname_len=${#OPTEE_3RD_TA_NAME}
  echo `printf "%0$(((16 - gname_len) * 2))x" 0` | xxd -r -p >>$f_out

  echo -n `printf "%s" ${OPTEE_3RD_TA_UUID}` >>$f_out
  gname_len=${#OPTEE_3RD_TA_UUID}
  echo `printf "%0$(((16 - gname_len) * 2))x" 0` | xxd -r -p >>$f_out

  l_endian32 $OPTEE_3RD_TA_TYPE >>$f_out
}

gen_secure_image(){
  f_in_extras=$1; shift
  f_in_payload=$1; shift
  f_out=$1; shift

  ##Check input files##
  [ -f $f_in_payload ]
  [ -f $f_in_extras ]

  ## Execytable for generating secure image ##
  exec_cmd=$GENX_TOOL
  [ -x $exec_cmd ]

  ## Prepare arguments ##
  unset exec_args

  ## Image Type ##
  exec_arg="${exec_arg} -t $OPTEE_3RD_TA_ImageType"

  ## Encryption Key ##
  exec_arg="${exec_arg} -k $OPTEE_3RD_TA_MDK"

  ## Signing Key ##
  exec_arg="${exec_arg} -n $OPTEE_3RD_TA_RSA_PRV"

  ## SegID and SegID Mask ##
  exec_arg="${exec_arg} -s $OPTEE_3RD_TA_SegID"
  exec_arg="${exec_arg} -S $OPTEE_3RD_TA_SegIDMask"

  ## Ver and Ver Mask ##
  exec_arg="${exec_arg} -r $OPTEE_3RD_TA_Ver"
  exec_arg="${exec_arg} -R $OPTEE_3RD_TA_VerMask"

  ## Extra part ##
  exec_arg="${exec_arg} -x $f_in_extras"

  ## Requested length. 0: use variable payload lenth. fixed lenth: use fixed lenth ##
  exec_arg="${exec_arg} -l 0x0"

  ## In Payload to be encrytped and signed ##
  exec_arg="${exec_arg} -i $f_in_payload"

  ## ouput file with encyrtion, signature and header info ##
  exec_arg="${exec_arg} -o $f_out"

  echo "$exec_cmd "$exec_arg""

  # Generate secure image ##
  eval $exec_cmd "$exec_arg"
}

pack_ta(){
  in_rootcert=$1; shift
  in_tacert=$1; shift
  in_ta=$1; shift
  f_out=$1; shift

  if [ ! -f $in_rootcert ];then
    echo "$in_rootcert doesn't exists, please generate it first"
    exit 1
  else
    echo "$in_rootcert exists"
  fi

  if [ ! -f $in_tacert ];then
    echo "$in_tacert doesn't exists, now generate it"
    source $ta_enc_dir/gen_ta_cert.sh $OPTEE_3RD_TA_PATH/$OPTEE_3RD_TA_BASENAME.ta
  else
    echo "$in_tacert exists"
  fi

  cat $in_rootcert $in_tacert $in_ta >$f_out

}


